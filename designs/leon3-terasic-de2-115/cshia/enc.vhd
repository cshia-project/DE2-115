-- File generated by bch.exe program.
-- The encoder for BCH code (127,64), t=10
-- Option= 3,  Interleave= 1, -- with optimization= 1.
-- GF(2^7) is generated by polynomial [1+x+...] - 11000001;
-------------------------------------------------------------------------
-- File enc.vhd consists following entities: enc, ering, ecount
--------------------------------------------------------------------------

-- LFSR for encoder
LIBRARY CSHIA;
USE CSHIA.bch.ALL;

ENTITY ering IS
PORT (clk, rll, din: IN BIT;
	dout: OUT BIT); --output serial data
END ering;

ARCHITECTURE eringa OF ering IS
	SIGNAL rin, rout: BIT_VECTOR(0 TO nk-1); -- ring register
	SIGNAL rin0: BIT;
  BEGIN
	dout<= rout(nk-1); 
 	rin0 <= (din XOR rout(nk-1)) AND rll;	

	rin(0)<= rin0;
	rin(1)<= rout(0) XOR rin0;
	rin(2)<= rout(1) XOR rin0;
	rin(3)<= rout(2) XOR rin0;
	rin(4)<= rout(3) XOR rin0;
	rin(5)<= rout(4);
	rin(6)<= rout(5);
	rin(7)<= rout(6);
	rin(8)<= rout(7);
	rin(9)<= rout(8) XOR rin0;
	rin(10)<= rout(9);
	rin(11)<= rout(10) XOR rin0;
	rin(12)<= rout(11);
	rin(13)<= rout(12) XOR rin0;
	rin(14)<= rout(13);
	rin(15)<= rout(14);
	rin(16)<= rout(15);
	rin(17)<= rout(16);
	rin(18)<= rout(17);
	rin(19)<= rout(18) XOR rin0;
	rin(20)<= rout(19) XOR rin0;
	rin(21)<= rout(20);
	rin(22)<= rout(21) XOR rin0;
	rin(23)<= rout(22);
	rin(24)<= rout(23) XOR rin0;
	rin(25)<= rout(24);
	rin(26)<= rout(25);
	rin(27)<= rout(26) XOR rin0;
	rin(28)<= rout(27) XOR rin0;
	rin(29)<= rout(28) XOR rin0;
	rin(30)<= rout(29);
	rin(31)<= rout(30) XOR rin0;
	rin(32)<= rout(31);
	rin(33)<= rout(32);
	rin(34)<= rout(33);
	rin(35)<= rout(34) XOR rin0;
	rin(36)<= rout(35) XOR rin0;
	rin(37)<= rout(36);
	rin(38)<= rout(37);
	rin(39)<= rout(38);
	rin(40)<= rout(39) XOR rin0;
	rin(41)<= rout(40);
	rin(42)<= rout(41) XOR rin0;
	rin(43)<= rout(42);
	rin(44)<= rout(43) XOR rin0;
	rin(45)<= rout(44);
	rin(46)<= rout(45) XOR rin0;
	rin(47)<= rout(46);
	rin(48)<= rout(47);
	rin(49)<= rout(48);
	rin(50)<= rout(49) XOR rin0;
	rin(51)<= rout(50);
	rin(52)<= rout(51);
	rin(53)<= rout(52);
	rin(54)<= rout(53);
	rin(55)<= rout(54) XOR rin0;
	rin(56)<= rout(55);
	rin(57)<= rout(56);
	rin(58)<= rout(57) XOR rin0;
	rin(59)<= rout(58);
	rin(60)<= rout(59) XOR rin0;
	rin(61)<= rout(60) XOR rin0;
	rin(62)<= rout(61) XOR rin0;
	-- Polynomial generating encoder: 1+a1*x+a2*x^2+...
	--1111100001010100000110101001110100011000101010100010000100101111
	-- Number of XOR gates= 27

  PROCESS BEGIN 
	WAIT UNTIL clk'EVENT AND clk='1';
	rout<= rin;
  END PROCESS;
END eringa;
--------------------------------------------------------------------------
-- COUNTER MODULO n FOR ENCODER BCH CODE (n,k)  
--  rll-ring loop lock - control signal for LFSR

LIBRARY CSHIA;
USE CSHIA.bch.ALL;

ENTITY ecount IS
PORT (clk, reset: IN BIT;
	vdin: OUT BIT);  
END ecount;

ARCHITECTURE ecounta OF ecount IS
	SIGNAL cout: BIT_VECTOR(0 TO m-1); -- cout in GF(2^m); cout= L^count 
	SIGNAL vdinR, vdinS, vdin1: BIT;
BEGIN
	vdinR<= cout(0) AND NOT cout(1) AND NOT cout(2) AND cout(3) AND NOT cout(4) AND NOT cout(5) AND NOT cout(6); 
		-- reset vdin if cout==k-1
	vdinS<= ( cout(0) AND NOT cout(1) AND NOT cout(2) AND NOT cout(3) AND NOT cout(4) AND NOT cout(5) AND cout(6)) OR reset; 
		-- vdinS=1 if cout==n-1
	vdin<= vdin1 AND NOT reset;

  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF vdinR='1' THEN
		vdin1<= '0';
	ELSIF vdinS='1' THEN
		vdin1<= '1';
	END IF;
  END PROCESS;	

  PROCESS BEGIN -- increment or reset cout in ring, cout=L^count
	WAIT UNTIL clk'EVENT AND clk='1';
	cout(0)<= cout(m-1) OR reset;
	cout(1)<= (cout(0) XOR cout(m-1)) AND NOT reset;
	cout(2)<= cout(1) AND NOT reset;
	cout(3)<= cout(2) AND NOT reset;
	cout(4)<= cout(3) AND NOT reset;
	cout(5)<= cout(4) AND NOT reset;
	cout(6)<= cout(5) AND NOT reset;
  END PROCESS;
END ecounta;

-----------------------------------------------------------------
--		ENCODER

LIBRARY CSHIA;
USE CSHIA.bch.ALL;

ENTITY enc IS
PORT (clk, reset, din: IN BIT; 
	vdin, dout: OUT BIT); --output serial data
END enc;  -- vdin - valid data in - to enable external data shifting

ARCHITECTURE enca OF enc IS
	SIGNAL vdin1, rin, rout, rll: BIT; 
		-- rll-ring loop lock, pe-parallel enable din

	COMPONENT ecount --counter encoder
		PORT(clk, reset: IN BIT; vdin: OUT BIT); 
	END COMPONENT;
	
	COMPONENT ering --ring for encoder
		PORT(clk, rll,  din: IN BIT; dout: OUT BIT); 
	END COMPONENT;
	
BEGIN	
	c1: ecount
		PORT MAP (clk, reset, vdin1);
	r1: ering
		PORT MAP (clk, rll, rin, rout);
	rin<= din AND NOT reset;
	rll<= vdin1 AND NOT reset;
	vdin<= vdin1;

  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	dout<= (NOT vdin1 AND rout) OR (vdin1 AND rin);
  END PROCESS;
END enca;
